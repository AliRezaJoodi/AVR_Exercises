// GitHub Account: GitHub.com/AliRezaJoodi

#include <tm1638.h>

#define TM1638_COMMAND_DATA_WRITE   0x40U  // Data command setting: Write data to display register
#define TM1638_COMMAND_DATA_READ    0x42U  // Data command setting: Read key scan data
#define TM1638_COMMAND_DISPLAY      0x80U  // Display control
#define TM1638_COMMAND_ADDRESS      0xC0U  // Address command setting

#define TM1638_PIN_INPUT            0U
#define TM1638_PIN_OUTPUT           1U

#define TM1638_DELAY(VALUE)         delay_us(VALUE);

//***************************************
static inline void TM1638_STB_ConfigPin(TM1638_t *tm, uint8_t mode){
    WRITE_BIT(*(tm->stb.ddr), tm->stb.index, mode);
    
    if(mode == TM1638_PIN_INPUT){ 
        CLEAR_BIT(*(tm->stb.port), tm->stb.index); // Disable pull-up
    }
    else{
        SET_BIT(*(tm->stb.port), tm->stb.index);  // Idle bus      
    }
}

//***************************************
void TM1638_STB_WritePin(TM1638_t *tm, uint8_t status){
    WRITE_BIT( *(tm->stb.port), tm->stb.index, status );
}

//***************************************
static inline void TM1638_CLK_ConfigPin(uint8_t mode){    
    WRITE_BIT(TM1638_CLK_DDR, TM1638_CLK_BIT, mode);
    
    if(mode == TM1638_PIN_INPUT){ 
        CLEAR_BIT(TM1638_CLK_PORT, TM1638_CLK_BIT); // Disable pull-up
    }
    else{
        SET_BIT(TM1638_CLK_PORT, TM1638_CLK_BIT); // Idle bus
    }
}

//***************************************
static inline void TM1638_CLK_WritePin(uint8_t status){
    WRITE_BIT(TM1638_CLK_PORT, TM1638_CLK_BIT, status);
}

//***************************************
static inline void TM1638_DIO_ConfigPin(uint8_t mode){
    WRITE_BIT(TM1638_DIO_DDR, TM1638_DIO_BIT, mode);
    
    if(mode == TM1638_PIN_INPUT){ 
        CLEAR_BIT(TM1638_DIO_PORT, TM1638_DIO_BIT); // Disable pull-up
    }
    else{
        SET_BIT(TM1638_DIO_PORT, TM1638_DIO_BIT); // Idle bus
    }
}

//***************************************
static inline void TM1638_DIO_WritePin(uint8_t status){
    WRITE_BIT(TM1638_DIO_PORT, TM1638_DIO_BIT, status); 
}

//***************************************
static inline uint8_t TM1638_DIO_GetPin(void){
    return GET_BIT(TM1638_DIO_PIN, TM1638_DIO_BIT);
}

//***************************************
void TM1638_WriteByte(uint8_t data){
    uint8_t i = 0;
  
    TM1638_DIO_ConfigPin(TM1638_PIN_OUTPUT);
  
    for(i = 0; i < 8; i++) {
        TM1638_CLK_WritePin(0);
        TM1638_DIO_WritePin(data & 0x01U);
        TM1638_DELAY(TM1637_BIT_US);
        TM1638_CLK_WritePin(1);
        TM1638_DELAY(TM1637_BIT_US);
        data = data >> 1;
    }
}

//***************************************
void TM1638_SendCommand(TM1638_t *tm, uint8_t command){
    TM1638_STB_WritePin(tm, 0);
    TM1638_WriteByte(command);
    TM1638_STB_WritePin(tm, 1);
    TM1638_DELAY(TM1637_BIT_US);
}

//***************************************
uint8_t TM1638_SetDisplay(TM1638_t *tm, uint8_t onoff, uint8_t brightness){
    uint8_t error =0;
    uint8_t command_display = TM1638_COMMAND_DISPLAY;
    
    if (onoff > 1){
        onoff = 1;
        SET_BIT(error, 0);
    }
    
    if (brightness > 0x07U){
        brightness = 0x07U;
        SET_BIT(error, 1);
    }
    
    WRITE_BIT(command_display, 3, onoff);
    WRITE_3BIT(command_display, 0, brightness);
    
    TM1638_STB_WritePin(tm, 0);   
    TM1638_WriteByte(command_display);     
    TM1638_STB_WritePin(tm, 1);
    TM1638_DELAY(TM1637_BIT_US);
    
    return error;
}

//***************************************
void TM1638_ResetSegments(TM1638_t *tm){
    uint8_t i=0;
    
    uint8_t command_address = TM1638_COMMAND_ADDRESS;
    WRITE_4BIT(command_address, 0, 0);	
    
    TM1638_STB_WritePin(tm, 0);    
    TM1638_WriteByte(TM1638_COMMAND_DATA_WRITE);    
    TM1638_STB_WritePin(tm, 1);
    TM1638_DELAY(TM1637_BIT_US);
    
	TM1638_STB_WritePin(tm, 0);
	TM1638_WriteByte(command_address);
	for(i=0; i<16; ++i){TM1638_WriteByte(0x00);}
	TM1638_STB_WritePin(tm, 1); 
    TM1638_DELAY(TM1637_BIT_US);  
}

//***************************************
void TM1638_Config(TM1638_t *tm){
    TM1638_STB_ConfigPin(tm, TM1638_PIN_OUTPUT);
    TM1638_STB_WritePin(tm, 1); // Idle bus

    TM1638_CLK_ConfigPin(TM1638_PIN_OUTPUT);
    TM1638_CLK_WritePin(1); // Idle bus
    
    TM1638_DIO_ConfigPin(TM1638_PIN_OUTPUT);    
    TM1638_DIO_WritePin(1); // Idle bus 
  
    TM1638_ResetSegments(tm);
    TM1638_SetDisplay(tm, 1, 7);
}

//***************************************
uint8_t TM1638_SetSegments_Seg1ToSeg10(TM1638_t *tm, uint8_t segments[], uint8_t length, uint8_t address){
    uint8_t error = 0;
    uint8_t i=0;    
    uint8_t command_address = TM1638_COMMAND_ADDRESS;
    
    if(address > 15){
        address = 15;
        SET_BIT(error, 0);   
    }
    
    if(length > (16-address)){
        length = 16 - address;
        SET_BIT(error, 1);    
    }
    else if(length == 0){
        length = 1;
        SET_BIT(error, 2); 
    }
    
    WRITE_4BIT(command_address, 0, address);	
    
    TM1638_STB_WritePin(tm,0);
    TM1638_WriteByte(TM1638_COMMAND_DATA_WRITE);
    TM1638_STB_WritePin(tm,1);
    TM1638_DELAY(TM1637_BIT_US);
    
	TM1638_STB_WritePin(tm, 0);    
	TM1638_WriteByte(command_address);
    
	for (i=0; i < length; ++i){
	  TM1638_WriteByte(segments[i] );
    }

	TM1638_STB_WritePin(tm,1);
    TM1638_DELAY(TM1637_BIT_US); 
    
    return error;   
}

//***************************************
uint8_t TM1638_SetSegments_FixedAddress(TM1638_t *tm, uint8_t data, uint8_t address){
    uint8_t error = 0;
    uint8_t command_address = TM1638_COMMAND_ADDRESS; 
    
    if(address > 15){
        address = 15;
        SET_BIT(error, 0);    
    }    
    WRITE_4BIT(command_address, 0, address);

    TM1638_STB_WritePin(tm, 0);    
    TM1638_WriteByte(TM1638_COMMAND_DATA_WRITE);
    TM1638_STB_WritePin(tm, 1);
    TM1638_DELAY(TM1637_BIT_US);
        
	TM1638_STB_WritePin(tm, 0);   
	TM1638_WriteByte(command_address); 
    TM1638_DELAY(TM1637_BIT_US);    
	TM1638_WriteByte(data);   
	TM1638_STB_WritePin(tm, 1);
    TM1638_DELAY(TM1637_BIT_US)
    
    return error;   
};

//***************************************
uint8_t TM1638_SetSegments_Seg1ToSeg8_OverWriteSeg9Seg10(TM1638_t *tm, uint8_t segments[], uint8_t length, uint8_t pos){
    uint8_t error = 0;
    uint8_t address = 0;
    uint8_t i=0;    
    uint8_t command_address = TM1638_COMMAND_ADDRESS; 
    
    if(pos > 7){
        pos = 7;
        SET_BIT(error, 0); 
    }
    
    if(length > (8-pos)){
        length = 8 - pos;
        SET_BIT(error, 1);    
    }
    else if(length == 0){
        length = 1;
        SET_BIT(error, 2); 
    }
    
    address = pos * 2;
    WRITE_4BIT(command_address, 0, address);	
    
    TM1638_STB_WritePin(tm, 0);    
    TM1638_WriteByte(TM1638_COMMAND_DATA_WRITE);     
    TM1638_STB_WritePin(tm, 1);
    TM1638_DELAY(TM1637_BIT_US);
    
	TM1638_STB_WritePin(tm, 0);    
	TM1638_WriteByte(command_address);
    
	for (i=0; i < length; ++i){
	  TM1638_WriteByte(segments[i] ); 
      TM1638_WriteByte(0x00);
    }

	TM1638_STB_WritePin(tm, 1);
    TM1638_DELAY(TM1637_BIT_US); 
    
    return error;  
}

//***************************************
uint8_t TM1638_SetSegments_Seg1ToSeg8_KeepSeg9Seg10(TM1638_t *tm, uint8_t segments[], uint8_t length, uint8_t pos){
    uint8_t error = 0;
    uint8_t address = 0;
    uint8_t i=0;    
    
    if(pos > 7){
        pos = 7;
        SET_BIT(error, 0); 
    }
    
    if(length > (8-pos)){
        length = 8 - pos;
        SET_BIT(error, 1);    
    }
    else if(length == 0){
        length = 1;
        SET_BIT(error, 2); 
    }
    
    address = pos * 2;
    
    for(i=0; i<length; ++i){
        TM1638_SetSegments_FixedAddress(tm, segments[i], address);
        address = address + 2;
    }
    
    return error; 
}

//***************************************
void TM1638_SetLeds_Seg9(TM1638_t *tm, uint8_t data){
 uint8_t i=0;
 
 for(i=0; i<8; ++i){
    TM1638_SetSegments_FixedAddress(tm, GET_BIT(data, i), (i*2)+1);   
 }
}

//***************************************
void TM1638_SetLeds_Seg9Seg10(TM1638_t *tm, uint16_t data){
 uint8_t i=0;
 
  for(i=0; i<8; ++i){
    TM1638_SetSegments_FixedAddress(tm, GET_2BIT(data, i*2), (i*2)+1); 
  }
}

//***************************************
uint8_t TM1638_ReadByte(void){
  uint8_t i = 0;
  uint8_t data = 0;
  uint8_t buf = 0;
  
  TM1638_DIO_ConfigPin(TM1638_PIN_INPUT);
  
  for(i = 0; i < 8; i++) {
    TM1638_CLK_WritePin(0);
    TM1638_DELAY(TM1637_BIT_US);
    TM1638_CLK_WritePin(1);
    
    buf = TM1638_DIO_GetPin();
    WRITE_BIT(data, i, buf);
    
    TM1638_DELAY(TM1637_BIT_US);
  }
  
  return data;
}

//***************************************
void TM1638_GetButtons_K1K2K3(TM1638_t *tm, uint8_t *key){
    uint8_t i =0;
    
    TM1638_STB_WritePin(tm, 0);  
    TM1638_WriteByte(TM1638_COMMAND_DATA_READ);
    TM1638_DIO_ConfigPin(TM1638_PIN_INPUT); 
    TM1638_DELAY(TM1637_BIT_US*2);  // Twait        
        
    for (i=0; i<4; ++i){ 
        TM1638_DELAY(TM1637_BIT_US);
	    *(key + i) = TM1638_ReadByte();
    }
    
    TM1638_DELAY(TM1637_BIT_US*2); 
    TM1638_STB_WritePin(tm, 1);
    TM1638_DELAY(TM1637_BIT_US*2);
    TM1638_DIO_ConfigPin(TM1638_PIN_OUTPUT);
}

//***************************************
void TM1638_GetButtons_K3(TM1638_t *tm, uint8_t *key){
    uint8_t i =0;
    uint8_t data =0;
    uint8_t buf =0;
   
    TM1638_STB_WritePin(tm, 0);  
    TM1638_WriteByte(TM1638_COMMAND_DATA_READ);
    TM1638_DIO_ConfigPin(TM1638_PIN_INPUT); 
    TM1638_DELAY(TM1637_BIT_US*2);  // Twait        
        
    for (i=0; i<4; ++i){
        TM1638_DELAY(TM1637_BIT_US);
	    buf = TM1638_ReadByte(); 
        data = data | (buf<<i);
    }
    
    TM1638_DELAY(TM1637_BIT_US*2); 
    TM1638_STB_WritePin(tm, 1);
    TM1638_DELAY(TM1637_BIT_US*2); 
    TM1638_DIO_ConfigPin(TM1638_PIN_OUTPUT);

    *key = data;
}

//***************************************
uint8_t TM1638_ReturnButtons_K3(TM1638_t *tm){
    uint8_t data = 0;

    TM1638_GetButtons_K3(tm, &data);    
    return data;
}